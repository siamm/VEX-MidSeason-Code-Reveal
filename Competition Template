#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl7,  Piston1,        sensorDigitalOut)
#pragma config(Sensor, dgtl8,  Piston2,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  Piston4,        sensorDigitalOut)
#pragma config(Sensor, I2C_1,  flipped,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port7,           flipped,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

	// Update inteval (in mS) for the flywheel control loop
	#define FW_LOOP_SPEED              1

	// Maximum power we want to send to the flywheel motors
	#define FW_MAX_POWER              120

	// encoder counts per revolution depending on motor
	#define MOTOR_TPR_269           240.448
	#define MOTOR_TPR_393R          261.333
	#define MOTOR_TPR_393S          392
	#define MOTOR_TPR_393T          627.2
	#define MOTOR_TPR_QUAD          360.0


	// encoder tick per revolution
	float           ticks_per_rev;          ///< encoder ticks per revolution


	// Encoder
	long            encoder_counts;         ///< current encoder count
	long            encoder_counts_last;    ///< current encoder count


	// velocity measurement
	float           motor_velocity;         ///< current velocity in rpm
	long            nSysTime_last;          ///< Time of last velocity calculation


	// TBH control algorithm variables
	long            target_velocity;        ///< target_velocity velocity
	float           current_error;          ///< error between actual and target_velocity velocities
	float           last_error;             ///< error last time update called
	float           gain;                   ///< gain
	float           drive;                  ///< final drive out of TBH (0.0 to 1.0)
	float           drive_at_zero;          ///< drive at last zero crossing
	long            first_cross;            ///< flag indicating first zero crossing
	float           drive_approx;           ///< estimated open loop drive


	// final motor drive
	long            motor_drive;            ///< final motor control value

const short leftButton = 1;
const short rightButton = 4;

float k = 7.3;

int count = 1;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

task Intaking()
{
	motor[port1] = motor[port10] = 127;
}

void MoveForwardALittle(int power1)
{
motor[port2] =
motor[port3] =
motor[port8] =
motor[port9] = ((k/nAvgBatteryLevel)/1000.0)*power1;
}

void Auton1()
{
SensorValue[Piston2] = 1;
startTask(Intaking);

motor[port2] =
motor[port3] =
motor[port8] =
motor[port9] = 45;
wait1Msec(1330);

motor[port2] =
motor[port3] =
motor[port8] =
motor[port9] = 10;
wait1Msec(2000);

motor[port2] =
motor[port3] =
motor[port8] =
motor[port9] = 45;
wait1Msec(1000);

stopTask(Intaking);

motor[port2] =
motor[port3] =
motor[port8] =
motor[port9] = -100;
wait1Msec(1);
}

void Auton3()
{
	motor[port1] =
	motor[port2] =
	motor[port3] =
	motor[port4] =
	motor[port5] =
	motor[port6] =
	motor[port7] =
	motor[port8] =
	motor[port9] =
	motor[port10] = 0;
}


void
	FwMotorSet( int value )
	{
	    motor[ port4] = value;
	    motor[ port5] = value;
	    motor[ port6 ] = value;
	    motor[ port7 ] = value;
	}


	/*-----------------------------------------------------------------------------*/
	/** @brief      Get the flywheen motor encoder count                           */
	/*-----------------------------------------------------------------------------*/
	long
	FwMotorEncoderGet()
	{
	    return( nMotorEncoder[ port7 ] );
	}


	/*-----------------------------------------------------------------------------*/
	/** @brief      Set the controller position                                    */
	/** @param[in]  desired velocity                                               */
	/** @param[in]  predicted_drive estimated open loop motor drive                */
	/*-----------------------------------------------------------------------------*/
	void
	FwVelocitySet( int velocity, float predicted_drive )
	{
	    // set target_velocity velocity (motor rpm)
	    target_velocity = velocity;


	    // Set error so zero crossing is correctly detected
	    current_error = target_velocity - motor_velocity;
	    last_error    = current_error;


	    // Set predicted open loop drive value
	    drive_approx  = predicted_drive;
	    // Set flag to detect first zero crossing
	    first_cross   = 1;
	    // clear tbh variable
	    drive_at_zero = 0;
	}


	/*-----------------------------------------------------------------------------*/
	/** @brief      Calculate the current flywheel motor velocity                  */
	/*-----------------------------------------------------------------------------*/
	void
	FwCalculateSpeed()
	{
	    int     delta_ms;
	    int     delta_enc;

	    // Get current encoder value
	    encoder_counts = FwMotorEncoderGet();


	    // This is just used so we don't need to know how often we are called
	    // how many mS since we were last here
	    delta_ms = nSysTime - nSysTime_last;
	    nSysTime_last = nSysTime;


	    // Change in encoder count
	    delta_enc = (encoder_counts - encoder_counts_last);


	    // save last position
	    encoder_counts_last = encoder_counts;


	    // Calculate velocity in rpm
	    motor_velocity = (1000.0 / delta_ms) * delta_enc * 60.0 / ticks_per_rev;
	}


	/*-----------------------------------------------------------------------------*/
	/** @brief      Update the velocity tbh controller variables                   */
	/*-----------------------------------------------------------------------------*/
	void
	FwControlUpdateVelocityTbh()
	{
	    // calculate error in velocity
	    // target_velocity is desired velocity
	    // current is measured velocity
	    current_error = target_velocity - motor_velocity;


	    // Calculate new control value
	    drive =  drive + (current_error * gain);


	    // Clip to the range 0 - 1.
	    // We are only going forwards
	    if( drive > 1 )
	    {
	          drive = 1;
	        }
	    if( drive < 0 )
	    {
	          drive = 0;
	        }


	    // Check for zero crossing
	    if( sgn(current_error) != sgn(last_error) )
	    {
	        // First zero crossing after a new set velocity command
	        if( first_cross )
	        	{
	            // Set drive to the open loop approximation
	            drive = drive_approx;
	            first_cross = 0;
	        	}
	        else
	        	{
	            drive = 0.5 * ( drive + drive_at_zero );
	          }


	        // Save this drive value in the "tbh" variable
	        drive_at_zero = drive;
	    }


	    // Save last error
	    last_error = current_error;
}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

  SensorValue[Piston1] = 0;
}

task FwControlTask()
	{
	    // Set the gain
	    gain = 0.00100; //0.00025

	    // We are using Speed geared motors
	    // Set the encoder ticks per revolution
	    ticks_per_rev = MOTOR_TPR_393R;


	    while(1)
	        {
	        // Calculate velocity
	        FwCalculateSpeed();


	        // Do the velocity TBH calculations
	        FwControlUpdateVelocityTbh() ;

	        // Scale drive into the range the motors need
	        motor_drive  = (drive * FW_MAX_POWER) + 0.5;

	        // Final Limit of motor values - don't really need this
	        if( motor_drive >  127 )
	        {
	        	motor_drive =  127;
	        }
	        if( motor_drive < -127 )
	        {
	        	motor_drive = -127;
	        }

	        // and finally set the motor control value
	        FwMotorSet( motor_drive );

	        // Run at somewhere between 20 and 50mS
	        wait1Msec( FW_LOOP_SPEED );
	        }
	}

task Flying()
{
	//FwVelocitySet(120, 0.56);
	motor[port4] = 70;
	motor[port5] = 70;
	motor[port6] = 70;
	motor[port7] = 70;

}

void Auton2()
{
	startTask(Flying);

	motor[port1] = motor[port10] = 127;
	wait1Msec(500);
	motor[port1] = motor[port10] = 0;
	wait1Msec(500);

	motor[port1] = motor[port10] = 127;
	wait1Msec(500);
	motor[port1] = motor[port10] = 0;
	wait1Msec(500);

	motor[port1] = motor[port10] = 127;
	wait1Msec(500);
	motor[port1] = motor[port10] = 0;
	wait1Msec(500);

	motor[port1] = motor[port10] = 127;
	wait1Msec(500);
	motor[port1] = motor[port10] = 0;
	wait1Msec(500);

	stopTask(Flying);
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
if (count == 1) Auton1();
else if (count == 2) Auton2();
else if (count == 3) Auton3();
}

	task Piston_43()
	{

					while (1)
					{
				SensorValue[Piston4] = 1;		//If larger or equal to optimal, retract
				wait1Msec(500);
				SensorValue [Piston4] = 0;
				wait1Msec(500);
				}
			}
task btn()
{

while(1)
{
FwVelocitySet( 156, 0.66 );	//144 , 0.63		152, 0.63
}
}
int x;
int y;




/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	   // Start the flywheel control task
	    startTask( FwControlTask );
				SensorValue[Piston4] = 1;
	while (true)
	{
	  motor[port2] = vexRT[Ch3] + vexRT[Ch1];
      	motor[port9] = vexRT[Ch3] + vexRT[Ch1];
				motor[port8] = vexRT[Ch3] - vexRT[Ch1];
				motor[port3] = vexRT[Ch3] - vexRT[Ch1];

				motor[port10] = vexRT[Ch2Xmtr2];

					if (vexRT[Btn6UXmtr2] == 1)
				{
					SensorValue[Piston2] = 0;
				}
				else
				{
					SensorValue[Piston2] = 1;
				}

				if (vexRT[Btn7U] == 1)
				{
					SensorValue[Piston1] = 0;
				}
				else if (vexRT[Btn7D] == 1)
				{
				SensorValue[Piston1] = 1;
				}

				if (vexRT[Btn8U] == 1 && abs(vexRT[Ch3])< 10 && abs(vexRT[Ch1])< 10)
				{
				motor[port2] = motor[port3] = motor[port8] = motor[port9] = 20;
				}
				else if (abs(vexRT[Ch3])< 10 && abs(vexRT[Ch1])< 10)
				{
				motor[port2] = motor[port3] = motor[port8] = motor[port9] = 0;
				}

				if (vexRT[Btn6U] == 1)
				{
					motor[port10] = 127;
					motor[port1] = 127;
				}
				else if (vexRT[Btn6D] == 1)
				{
					motor[port10] = -127;
					motor[port1] = -127;
				}
				else
				{
					motor[port1] = motor[port10] = vexRT[Ch2Xmtr2];
				}

				if( vexRT[ Btn5DXmtr2 ] == 1 )//Base Shoot (from colour tile) (slow)
	       {
	            FwVelocitySet( 180, 0.64);		//180, 0.64

	          }
	     else if (vexRT[Btn7LXmtr2] == 1)//Base Shoot Fast
	     {
	       FwVelocitySet(240, 1.00);
	   }
	   else if (vexRT[Btn5UXmtr2] == 1)//Shoot from Mid
	   {
	    FwVelocitySet(169, 0.54);
	 }
	 	else if (vexRT[Btn7RXmtr2] == 1) //Same-net shooting (Robot skills)
	 	{
	 		FwVelocitySet(204, 0.64);
	}
else if((vexRT[Btn8LXmtr2] ==1 || vexRT[Btn8L] ==1)&& x == 0)
{

if(y==0)
{
	startTask(btn);
	startTask(Piston_43);
}
else if(y==1)
{
	stopTask(btn);
	stopTask(Piston_43);

					encoder_counts = 0;
				encoder_counts_last = 0;
				motor_velocity = 0;
				nSysTime_last = 0;

				target_velocity = 0; //Target will be reset
				current_error = 0;
				last_error = 0;
				drive = 0;
				drive_at_zero = 0;
				first_cross = 0;
				drive_approx = 0;
				motor_drive = 0;
				FwMotorSet(0);
				motor[port4] = motor[port5] = motor[port6] = motor[port7] = 0; //Actually might not even need this
				SensorValue[Piston4] = 1;

				}
x=1;
}
else if((vexRT[Btn8L] ==0 && vexRT[Btn8LXmtr2] ==0) && x ==1)
{
if(y==0)
{
y=1;
}
else if (y==1)
{
y=0;
}
x=0;
}

else
{

FwVelocitySet(0, 0);
	          }



//Count Calculation
if(nLCDButtons == leftButton) count = count - 1;
if(nLCDButtons == rightButton) count = count + 1;

if (count <= 0) count = 1;
if (count >= 4) count = 1;

//Count Display
if (count == 1)
{
clearLCDLine(0);
clearLCDLine(1);
displayLCDCenteredString(0, "Autonomous 1");
displayLCDCenteredString(1, "<                      >");
}
else if (count == 2)
{
clearLCDLine(0);
clearLCDLine(1);
displayLCDCenteredString(0, "Autonomous 2");
displayLCDCenteredString(1, "<                      >");
}
else if (count == 3)
{
clearLCDLine(0);
clearLCDLine(1);
displayLCDCenteredString(0, "Autonomous 3");
displayLCDNumber(1, 3, (abs(motor[port7])) , 6);
}
/*
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
clearLCDLine(0);								//Clear LCD Lines
clearLCDLine(1);

//Display Motor Power Level
displayLCDNumber(1, 3, (abs(motor[port7])) , 6);

//Short delay for refresh rate
wait1Msec(100);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
	}
}
